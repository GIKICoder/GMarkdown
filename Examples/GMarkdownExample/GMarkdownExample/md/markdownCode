# 多语言代码高亮测试文档

这是一个包含各种编程语言的 Markdown 文档，用于测试代码高亮功能。

## 前端开发语言

### HTML
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试页面</title>
</head>
<body>
    <div class="container">
        <h1>Hello World</h1>
        <p>这是一个测试页面</p>
    </div>
</body>
</html>
```

### CSS
```css
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

h1 {
    color: #333;
    font-size: 2.5rem;
    text-align: center;
    transition: all 0.3s ease;
}

h1:hover {
    transform: scale(1.05);
    color: #007bff;
}
```

### JavaScript
```javascript
// ES6+ 特性示例
const fetchUserData = async (userId) => {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        
        return {
            ...userData,
            fullName: `${userData.firstName} ${userData.lastName}`,
            isActive: userData.status === 'active'
        };
    } catch (error) {
        console.error('获取用户数据失败:', error);
        throw new Error('用户数据获取失败');
    }
};

// 类定义
class UserManager {
    constructor() {
        this.users = new Map();
    }
    
    addUser(user) {
        this.users.set(user.id, user);
    }
    
    getUser(id) {
        return this.users.get(id);
    }
}
```

### TypeScript
```typescript
interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user' | 'guest';
    createdAt: Date;
}

type UserRole = User['role'];

class ApiService<T> {
    private baseUrl: string;
    
    constructor(baseUrl: string) {
        this.baseUrl = baseUrl;
    }
    
    async get<K extends keyof T>(endpoint: string): Promise<T[K]> {
        const response = await fetch(`${this.baseUrl}/${endpoint}`);
        return response.json();
    }
    
    async post<K extends keyof T>(endpoint: string, data: Partial<T>): Promise<T[K]> {
        const response = await fetch(`${this.baseUrl}/${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        return response.json();
    }
}

const userService = new ApiService<User>('/api');
```

## 后端开发语言

### Python
```python
import asyncio
import aiohttp
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class User:
    id: int
    username: str
    email: str
    created_at: datetime
    is_active: bool = True

class UserRepository:
    def __init__(self, db_connection):
        self.db = db_connection
    
    async def create_user(self, user_data: Dict) -> User:
        query = """
        INSERT INTO users (username, email, created_at)
        VALUES (%(username)s, %(email)s, %(created_at)s)
        RETURNING id, username, email, created_at, is_active
        """
        
        async with self.db.acquire() as conn:
            result = await conn.fetchrow(query, user_data)
            return User(**dict(result))
    
    async def get_users(self, limit: int = 10) -> List[User]:
        query = "SELECT * FROM users WHERE is_active = TRUE LIMIT $1"
        async with self.db.acquire() as conn:
            rows = await conn.fetch(query, limit)
            return [User(**dict(row)) for row in rows]

# 装饰器示例
def retry(max_attempts: int = 3):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    await asyncio.sleep(2 ** attempt)
        return wrapper
    return decorator
```

### Java
```java
package com.example.service;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public CompletableFuture<List<UserDto>> getActiveUsers() {
        return CompletableFuture.supplyAsync(() -> {
            return userRepository.findByIsActiveTrue()
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
        });
    }
    
    @Transactional
    public User createUser(CreateUserRequest request) {
        validateUserRequest(request);
        
        User user = User.builder()
            .username(request.getUsername())
            .email(request.getEmail())
            .createdAt(LocalDateTime.now())
            .isActive(true)
            .build();
            
        User savedUser = userRepository.save(user);
        
        // 异步发送欢迎邮件
        emailService.sendWelcomeEmailAsync(savedUser.getEmail());
        
        return savedUser;
    }
    
    private void validateUserRequest(CreateUserRequest request) {
        if (request.getUsername() == null || request.getUsername().trim().isEmpty()) {
            throw new IllegalArgumentException("用户名不能为空");
        }
        
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new DuplicateUserException("用户名已存在");
        }
    }
    
    private UserDto convertToDto(User user) {
        return UserDto.builder()
            .id(user.getId())
            .username(user.getUsername())
            .email(user.getEmail())
            .createdAt(user.getCreatedAt())
            .build();
    }
}
```

### C#
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace UserManagement.Services
{
    public interface IUserService
    {
        Task<IEnumerable<UserDto>> GetUsersAsync(int page = 1, int pageSize = 10);
        Task<UserDto> CreateUserAsync(CreateUserRequest request);
        Task<bool> DeleteUserAsync(int userId);
    }

    public class UserService : IUserService
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<UserService> _logger;
        private readonly IEmailService _emailService;

        public UserService(
            ApplicationDbContext context,
            ILogger<UserService> logger,
            IEmailService emailService)
        {
            _context = context;
            _logger = logger;
            _emailService = emailService;
        }

        public async Task<IEnumerable<UserDto>> GetUsersAsync(int page = 1, int pageSize = 10)
        {
            try
            {
                var users = await _context.Users
                    .Where(u => u.IsActive)
                    .OrderByDescending(u => u.CreatedAt)
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .Select(u => new UserDto
                    {
                        Id = u.Id,
                        Username = u.Username,
                        Email = u.Email,
                        CreatedAt = u.CreatedAt
                    })
                    .ToListAsync();

                return users;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "获取用户列表时发生错误");
                throw;
            }
        }

        public async Task<UserDto> CreateUserAsync(CreateUserRequest request)
        {
            using var transaction = await _context.Database.BeginTransactionAsync();
            
            try
            {
                var user = new User
                {
                    Username = request.Username,
                    Email = request.Email,
                    CreatedAt = DateTime.UtcNow,
                    IsActive = true
                };

                _context.Users.Add(user);
                await _context.SaveChangesAsync();

                await transaction.CommitAsync();

                // 发送欢迎邮件
                _ = Task.Run(async () => await _emailService.SendWelcomeEmailAsync(user.Email));

                return new UserDto
                {
                    Id = user.Id,
                    Username = user.Username,
                    Email = user.Email,
                    CreatedAt = user.CreatedAt
                };
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                _logger.LogError(ex, "创建用户时发生错误: {Username}", request.Username);
                throw;
            }
        }

        public async Task<bool> DeleteUserAsync(int userId)
        {
            var user = await _context.Users.FindAsync(userId);
            if (user == null) return false;

            user.IsActive = false;
            await _context.SaveChangesAsync();

            return true;
        }
    }
}
```

### Go
```go
package main

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "time"

    "github.com/gorilla/mux"
    _ "github.com/lib/pq"
)

type User struct {
    ID        int       `json:"id" db:"id"`
    Username  string    `json:"username" db:"username"`
    Email     string    `json:"email" db:"email"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    IsActive  bool      `json:"is_active" db:"is_active"`
}

type UserService struct {
    db *sql.DB
}

func NewUserService(db *sql.DB) *UserService {
    return &UserService{db: db}
}

func (s *UserService) GetUsers(ctx context.Context, limit int) ([]User, error) {
    query := `
        SELECT id, username, email, created_at, is_active 
        FROM users 
        WHERE is_active = true 
        ORDER BY created_at DESC 
        LIMIT $1
    `
    
    rows, err := s.db.QueryContext(ctx, query, limit)
    if err != nil {
        return nil, fmt.Errorf("查询用户失败: %w", err)
    }
    defer rows.Close()

    var users []User
    for rows.Next() {
        var user User
        err := rows.Scan(&user.ID, &user.Username, &user.Email, &user.CreatedAt, &user.IsActive)
        if err != nil {
            return nil, fmt.Errorf("扫描用户数据失败: %w", err)
        }
        users = append(users, user)
    }

    return users, nil
}

func (s *UserService) CreateUser(ctx context.Context, username, email string) (*User, error) {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("开始事务失败: %w", err)
    }
    defer tx.Rollback()

    query := `
        INSERT INTO users (username, email, created_at, is_active)
        VALUES ($1, $2, $3, $4)
        RETURNING id, username, email, created_at, is_active
    `

    var user User
    err = tx.QueryRowContext(ctx, query, username, email, time.Now(), true).Scan(
        &user.ID, &user.Username, &user.Email, &user.CreatedAt, &user.IsActive,
    )
    if err != nil {
        return nil, fmt.Errorf("创建用户失败: %w", err)
    }

    if err = tx.Commit(); err != nil {
        return nil, fmt.Errorf("提交事务失败: %w", err)
    }

    return &user, nil
}

// HTTP 处理器
type UserHandler struct {
    service *UserService
}

func (h *UserHandler) GetUsersHandler(w http.ResponseWriter, r *http.Request) {
    limitStr := r.URL.Query().Get("limit")
    limit := 10
    if limitStr != "" {
        if l, err := strconv.Atoi(limitStr); err == nil {
            limit = l
        }
    }

    users, err := h.service.GetUsers(r.Context(), limit)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func main() {
    db, err := sql.Open("postgres", "postgres://user:password@localhost/dbname?sslmode=disable")
    if err != nil {
        log.Fatal("连接数据库失败:", err)
    }
    defer db.Close()

    userService := NewUserService(db)
    userHandler := &UserHandler{service: userService}

    r := mux.NewRouter()
    r.HandleFunc("/users", userHandler.GetUsersHandler).Methods("GET")

    log.Println("服务器启动在 :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

### Rust
```rust
use serde::{Deserialize, Serialize};
use sqlx::{PgPool, Row};
use std::collections::HashMap;
use tokio;
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub is_active: bool,
}

#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub username: String,
    pub email: String,
}

pub struct UserRepository {
    pool: PgPool,
}

impl UserRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    pub async fn create_user(&self, request: CreateUserRequest) -> Result<User, sqlx::Error> {
        let user_id = Uuid::new_v4();
        let now = Utc::now();

        let user = sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (id, username, email, created_at, is_active)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id, username, email, created_at, is_active
            "#,
            user_id,
            request.username,
            request.email,
            now,
            true
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(user)
    }

    pub async fn get_users(&self, limit: i64) -> Result<Vec<User>, sqlx::Error> {
        let users = sqlx::query_as!(
            User,
            r#"
            SELECT id, username, email, created_at, is_active
            FROM users
            WHERE is_active = true
            ORDER BY created_at DESC
            LIMIT $1
            "#,
            limit
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(users)
    }

    pub async fn find_by_id(&self, user_id: Uuid) -> Result<Option<User>, sqlx::Error> {
        let user = sqlx::query_as!(
            User,
            "SELECT id, username, email, created_at, is_active FROM users WHERE id = $1",
            user_id
        )
        .fetch_optional(&self.pool)
        .await?;

        Ok(user)
    }
}

// 异步处理示例
pub async fn process_users_batch(
    repository: &UserRepository,
    user_ids: Vec<Uuid>,
) -> Result<HashMap<Uuid, User>, Box<dyn std::error::Error>> {
    let mut results = HashMap::new();
    let mut handles = vec![];

    for user_id in user_ids {
        let repo = repository.clone();
        let handle = tokio::spawn(async move {
            repo.find_by_id(user_id).await
        });
        handles.push((user_id, handle));
    }

    for (user_id, handle) in handles {
        match handle.await? {
            Ok(Some(user)) => {
                results.insert(user_id, user);
            }
            Ok(None) => {
                eprintln!("用户未找到: {}", user_id);
            }
            Err(e) => {
                eprintln!("获取用户失败 {}: {}", user_id, e);
            }
        }
    }

    Ok(results)
}

// 错误处理
#[derive(Debug)]
pub enum UserError {
    DatabaseError(sqlx::Error),
    ValidationError(String),
    NotFound,
}

impl std::fmt::Display for UserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UserError::DatabaseError(e) => write!(f, "数据库错误: {}", e),
            UserError::ValidationError(msg) => write!(f, "验证错误: {}", msg),
            UserError::NotFound => write!(f, "用户未找到"),
        }
    }
}

impl std::error::Error for UserError {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let database_url = std::env::var("DATABASE_URL")?;
    let pool = PgPool::connect(&database_url).await?;
    
    let repository = UserRepository::new(pool);
    
    let users = repository.get_users(10).await?;
    println!("找到 {} 个用户", users.len());
    
    for user in users {
        println!("用户: {} ({})", user.username, user.email);
    }
    
    Ok(())
}
```

## 数据库语言

### SQL
```sql
-- 创建用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    last_login TIMESTAMP WITH TIME ZONE
);

-- 创建用户角色表
CREATE TABLE user_roles (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    role_name VARCHAR(50) NOT NULL,
    granted_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    granted_by INTEGER REFERENCES users(id)
);

-- 创建索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_active ON users(is_active);
CREATE INDEX idx_user_roles_user_id ON user_roles(user_id);

-- 复杂查询示例
WITH active_users AS (
    SELECT 
        u.id,
        u.username,
        u.email,
        u.created_at,
        COUNT(ur.id) as role_count
    FROM users u
    LEFT JOIN user_roles ur ON u.id = ur.user_id
    WHERE u.is_active = TRUE
    GROUP BY u.id, u.username, u.email, u.created_at
),
user_stats AS (
    SELECT 
        DATE_TRUNC('month', created_at) as month,
        COUNT(*) as user_count
    FROM users
    WHERE created_at >= CURRENT_DATE - INTERVAL '12 months'
    GROUP BY DATE_TRUNC('month', created_at)
)
SELECT 
    au.username,
    au.email,
    au.role_count,
    CASE 
        WHEN au.role_count > 2 THEN 'Power User'
        WHEN au.role_count > 0 THEN 'Regular User'
        ELSE 'Basic User'
    END as user_type
FROM active_users au
ORDER BY au.role_count DESC, au.created_at DESC
LIMIT 50;

-- 存储过程示例
CREATE OR REPLACE FUNCTION update_user_last_login(user_id INTEGER)
RETURNS VOID AS $$
BEGIN
    UPDATE users 
    SET 
        last_login = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = user_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION '用户ID % 不存在', user_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 触发器示例
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

## 配置文件

### YAML
```yaml
# 应用配置
app:
  name: "用户管理系统"
  version: "1.0.0"
  environment: "production"
  debug: false
  
server:
  host: "0.0.0.0"
  port: 8080
  timeout:
    read: 30s
    write: 30s
    idle: 120s
  
database:
  driver: "postgres"
  host: "localhost"
  port: 5432
  name: "userdb"
  username: "dbuser"
  password: "${DB_PASSWORD}"
  ssl_mode: "require"
  max_connections: 25
  max_idle_connections: 5
  connection_max_lifetime: "1h"
  
redis:
  host: "localhost"
  port: 6379
  password: "${REDIS_PASSWORD}"
  db: 0
  pool_size: 10
  
logging:
  level: "info"
  format: "json"
  output: "stdout"
  file:
    enabled: true
    path: "/var/log/app.log"
    max_size: "100MB"
    max_backups: 5
    max_age: 30
    
security:
  jwt:
    secret: "${JWT_SECRET}"
    expiration: "24h"
    refresh_expiration: "7d"
  cors:
    allowed_origins:
      - "https://example.com"
      - "https://app.example.com"
    allowed_methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
    allowed_headers:
      - "Content-Type"
      - "Authorization"
    
features:
  email_verification: true
  two_factor_auth: false
  rate_limiting: true
  metrics: true
```

### JSON
```json
{
  "name": "user-management-api",
  "version": "1.0.0",
  "description": "用户管理系统 API",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "build": "webpack --mode production",
    "docker:build": "docker build -t user-api .",
    "docker:run": "docker run -p 8080:8080 user-api"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.3",
    "jsonwebtoken": "^9.0.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "helmet": "^6.1.5",
    "express-rate-limit": "^6.7.0",
    "joi": "^17.9.1",
    "nodemailer": "^6.9.1",
    "redis": "^4.6.5",
    "winston": "^3.8.2"
  },
  "devDependencies": {
    "nodemon": "^2.0.22",
    "jest": "^29.5.0",
    "supertest": "^6.3.3",
    "eslint": "^8.39.0",
    "prettier": "^2.8.8",
    "webpack": "^5.82.1",
    "webpack-cli": "^5.1.1"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/example/user-management-api.git"
  },
  "keywords": [
    "api",
    "user-management",
    "express",
    "mongodb",
    "jwt",
    "authentication"
  ],
  "author": "开发团队",
  "license": "MIT",
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.js",
      "!src/index.js"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### XML
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appSettings>
        <add key="ApplicationName" value="用户管理系统" />
        <add key="Version" value="1.0.0" />
        <add key="Environment" value="Production" />
        <add key="Debug" value="false" />
    </appSettings>
    
    <connectionStrings>
        <add name="DefaultConnection" 
             connectionString="Server=localhost;Database=UserDB;User Id=dbuser;Password=password;Encrypt=true;TrustServerCertificate=true;" 
             providerName="System.Data.SqlClient" />
        <add name="RedisConnection" 
             connectionString="localhost:6379" />
    </connectionStrings>
    
    <system.web>
        <compilation debug="false" targetFramework="4.8" />
        <httpRuntime targetFramework="4.8" maxRequestLength="4096" />
        <authentication mode="Forms">
            <forms loginUrl="~/Account/Login" timeout="2880" />
        </authentication>
        <authorization>
            <deny users="?" />
        </authorization>
        <customErrors mode="RemoteOnly" defaultRedirect="~/Error/Index">
            <error statusCode="404" redirect="~/Error/NotFound" />
            <error statusCode="500" redirect="~/Error/ServerError" />
        </customErrors>
    </system.web>
    
    <system.webServer>
        <defaultDocument>
            <files>
                <clear />
                <add value="index.html" />
                <add value="default.aspx" />
            </files>
        </defaultDocument>
        <httpErrors errorMode="Custom">
            <remove statusCode="404" subStatusCode="-1" />
            <error statusCode="404" path="/Error/NotFound" responseMode="ExecuteURL" />
        </httpErrors>
    </system.webServer>
    
    <log4net>
        <appender name="FileAppender" type="log4net.Appender.RollingFileAppender">
            <file value="logs/application.log" />
            <appendToFile value="true" />
            <rollingStyle value="Size" />
            <maxSizeRollBackups value="10" />
            <maximumFileSize value="10MB" />
            <layout type="log4net.Layout.PatternLayout">
                <conversionPattern value="%date [%thread] %-5level %logger - %message%newline" />
            </layout>
        </appender>
        <root>
            <level value="INFO" />
            <appender-ref ref="FileAppender" />
        </root>
    </log4net>
</configuration>
```

## Shell 脚本

### Bash
```bash
#!/bin/bash

# 用户管理系统部署脚本
set -euo pipefail

# 配置变量
APP_NAME="user-management-api"
APP_VERSION="1.0.0"
DEPLOY_DIR="/opt/${APP_NAME}"
BACKUP_DIR="/opt/backups"
LOG_FILE="/var/log/deploy.log"
DOCKER_IMAGE="${APP_NAME}:${APP_VERSION}"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 日志函数
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}" | tee -a "$LOG_FILE"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}" | tee -a "$LOG_FILE"
    exit 1
}

# 检查依赖
check_dependencies() {
    log "检查系统依赖..."
    
    local deps=("docker" "docker-compose" "curl" "jq")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            error "依赖 $dep 未安装"
        fi
    done
    
    log "所有依赖检查通过"
}

# 创建备份
create_backup() {
    log "创建应用备份..."
    
    if [ -d "$DEPLOY_DIR" ]; then
        local backup_name="${APP_NAME}_$(date +%Y%m%d_%H%M%S).tar.gz"
        local backup_path="${BACKUP_DIR}/${backup_name}"
        
        mkdir -p "$BACKUP_DIR"
        tar -czf "$backup_path" -C "$(dirname "$DEPLOY_DIR")" "$(basename "$DEPLOY_DIR")"
        
        log "备份创建成功: $backup_path"
        
        # 清理旧备份（保留最近5个）
        find "$BACKUP_DIR" -name "${APP_NAME}_*.tar.gz" -type f -printf '%T@ %p\n' | \
            sort -rn | tail -n +6 | cut -d' ' -f2- | xargs -r rm -f
    else
        warn "部署目录不存在，跳过备份"
    fi
}

# 部署应用
deploy_application() {
    log "开始部署应用..."
    
    # 停止现有服务
    if docker-compose -f "${DEPLOY_DIR}/docker-compose.yml" ps -q &> /dev/null; then
        log "停止现有服务..."
        docker-compose -f "${DEPLOY_DIR}/docker-compose.yml" down
    fi
    
    # 创建部署目录
    mkdir -p "$DEPLOY_DIR"
    
    # 复制配置文件
    cp docker-compose.yml "$DEPLOY_DIR/"
    cp .env.production "${DEPLOY_DIR}/.env"
    
    # 拉取最新镜像
    log "拉取Docker镜像..."
    docker pull "$DOCKER_IMAGE"
    
    # 启动服务
    log "启动服务..."
    cd "$DEPLOY_DIR"
    docker-compose up -d
    
    # 等待服务启动
    log "等待服务启动..."
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s http://localhost:8080/health > /dev/null; then
            log "服务启动成功"
            break
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            error "服务启动超时"
        fi
        
        log "等待服务启动... ($attempt/$max_attempts)"
        sleep 10
        ((attempt++))
    done
}

# 运行健康检查
health_check() {
    log "运行健康检查..."
    
    local health_url="http://localhost:8080/health"
    local response
    
    response=$(curl -s "$health_url" | jq -r '.status')
    
    if [ "$response" = "healthy" ]; then
        log "健康检查通过"
    else
        error "健康检查失败: $response"
    fi
}

# 清理函数
cleanup() {
    log "执行清理操作..."
    
    # 清理未使用的Docker镜像
    docker image prune -f
    
    # 清理旧的日志文件
    find /var/log -name "*.log" -type f -mtime +30 -delete 2>/dev/null || true
    
    log "清理完成"
}

# 主函数
main() {
    log "开始部署 ${APP_NAME} v${APP_VERSION}"
    
    # 检查是否为root用户
    if [ "$EUID" -ne 0 ]; then
        error "请使用root用户运行此脚本"
    fi
    
    check_dependencies
    create_backup
    deploy_application
    health_check
    cleanup
    
    log "部署完成！"
    log "应用访问地址: http://localhost:8080"
    log "日志查看命令: docker-compose -f ${DEPLOY_DIR}/docker-compose.yml logs -f"
}

# 信号处理
trap 'error "脚本被中断"' INT TERM

# 执行主函数
main "$@"
```

## 其他语言

### PHP
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\User;
use App\Repositories\UserRepository;
use App\Exceptions\UserNotFoundException;
use App\Exceptions\ValidationException;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

class UserService
{
    private UserRepository $userRepository;
    
    public function __construct(UserRepository $userRepository)
    {
        $this->userRepository = $userRepository;
    }
    
    /**
     * 获取用户列表
     */
    public function getUsers(int $page = 1, int $perPage = 10): array
    {
        $cacheKey = "users_page_{$page}_per_page_{$perPage}";
        
        return Cache::remember($cacheKey, 300, function () use ($page, $perPage) {
            return $this->userRepository->paginate($page, $perPage);
        });
    }
    
    /**
     * 创建新用户
     */
    public function createUser(array $userData): User
    {
        $this->validateUserData($userData);
        
        try {
            $user = new User([
                'username' => $userData['username'],
                'email' => $userData['email'],
                'password' => Hash::make($userData['password']),
                'created_at' => Carbon::now(),
                'is_active' => true,
            ]);
            
            $savedUser = $this->userRepository->save($user);
            
            // 发送欢迎邮件
            $this->sendWelcomeEmail($savedUser);
            
            // 清除缓存
            Cache::tags(['users'])->flush();
            
            Log::info('用户创建成功', ['user_id' => $savedUser->id, 'username' => $savedUser->username]);
            
            return $savedUser;
            
        } catch (\Exception $e) {
            Log::error('用户创建失败', [
                'error' => $e->getMessage(),
                'userData' => $userData
            ]);
            throw $e;
        }
    }
    
    /**
     * 更新用户信息
     */
    public function updateUser(int $userId, array $updateData): User
    {
        $user = $this->userRepository->findById($userId);
        
        if (!$user) {
            throw new UserNotFoundException("用户ID {$userId} 不存在");
        }
        
        $this->validateUpdateData($updateData);
        
        foreach ($updateData as $field => $value) {
            if (in_array($field, ['username', 'email', 'is_active'])) {
                $user->{$field} = $value;
            }
        }
        
        $user->updated_at = Carbon::now();
        $updatedUser = $this->userRepository->save($user);
        
        // 清除相关缓存
        Cache::forget("user_{$userId}");
        Cache::tags(['users'])->flush();
        
        return $updatedUser;
    }
    
    /**
     * 软删除用户
     */
    public function deleteUser(int $userId): bool
    {
        $user = $this->userRepository->findById($userId);
        
        if (!$user) {
            throw new UserNotFoundException("用户ID {$userId} 不存在");
        }
        
        $user->is_active = false;
        $user->deleted_at = Carbon::now();
        
        $this->userRepository->save($user);
        
        // 清除缓存
        Cache::forget("user_{$userId}");
        Cache::tags(['users'])->flush();
        
        Log::info('用户已删除', ['user_id' => $userId]);
        
        return true;
    }
    
    /**
     * 验证用户数据
     */
    private function validateUserData(array $data): void
    {
        $rules = [
            'username' => 'required|string|min:3|max:50|unique:users',
            'email' => 'required|email|unique:users',
            'password' => 'required|string|min:8|regex:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/',
        ];
        
        $validator = validator($data, $rules);
        
        if ($validator->fails()) {
            throw new ValidationException($validator->errors()->first());
        }
    }
    
    /**
     * 验证更新数据
     */
    private function validateUpdateData(array $data): void
    {
        $allowedFields = ['username', 'email', 'is_active'];
        $invalidFields = array_diff(array_keys($data), $allowedFields);
        
        if (!empty($invalidFields)) {
            throw new ValidationException('不允许更新的字段: ' . implode(', ', $invalidFields));
        }
        
        if (isset($data['email']) && !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            throw new ValidationException('邮箱格式不正确');
        }
    }
    
    /**
     * 发送欢迎邮件
     */
    private function sendWelcomeEmail(User $user): void
    {
        try {
            Mail::to($user->email)->send(new \App\Mail\WelcomeEmail($user));
        } catch (\Exception $e) {
            Log::warning('欢迎邮件发送失败', [
                'user_id' => $user->id,
                'email' => $user->email,
                'error' => $e->getMessage()
            ]);
        }
    }
    
    /**
     * 获取用户统计信息
     */
    public function getUserStats(): array
    {
        return Cache::remember('user_stats', 3600, function () {
            return [
                'total_users' => $this->userRepository->count(),
                'active_users' => $this->userRepository->countActive(),
                'new_users_today' => $this->userRepository->countCreatedToday(),
                'new_users_this_month' => $this->userRepository->countCreatedThisMonth(),
            ];
        });
    }
}

// 用户模型
class User extends \Illuminate\Database\Eloquent\Model
{
    protected $fillable = [
        'username', 'email', 'password', 'is_active', 'created_at'
    ];
    
    protected $hidden = [
        'password'
    ];
    
    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];
    
    public function getFullNameAttribute(): string
    {
        return $this->first_name . ' ' . $this->last_name;
    }
    
    public function isActive(): bool
    {
        return $this->is_active && is_null($this->deleted_at);
    }
}
```

### Ruby
```ruby
# frozen_string_literal: true

require 'active_record'
require 'bcrypt'
require 'mail'
require 'redis'
require 'json'

# 用户模型
class User < ActiveRecord::Base
  include BCrypt
  
  validates :username, presence: true, uniqueness: true, length: { minimum: 3, maximum: 50 }
  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :password, presence: true, length: { minimum: 8 }, if: :password_required?
  
  before_save :encrypt_password, if: :password_changed?
  before_create :set_default_values
  
  scope :active, -> { where(is_active: true) }
  scope :created_today, -> { where('created_at >= ?', Date.current.beginning_of_day) }
  scope :created_this_month, -> { where('created_at >= ?', Date.current.beginning_of_month) }
  
  def password
    @password ||= Password.new(password_hash) if password_hash
  end
  
  def password=(new_password)
    @password = Password.create(new_password)
    self.password_hash = @password
  end
  
  def authenticate(password)
    self.password == password
  end
  
  def active?
    is_active && !deleted_at
  end
  
  def soft_delete!
    update!(is_active: false, deleted_at: Time.current)
  end
  
  private
  
  def password_required?
    password_hash.blank? || password.present?
  end
  
  def password_changed?
    password.present?
  end
  
  def encrypt_password
    self.password_hash = password
  end
  
  def set_default_values
    self.is_active = true if is_active.nil?
    self.created_at = Time.current
  end
end

# 用户服务类
class UserService
  include ActiveModel::Validations
  
  def initialize(redis_client = nil)
    @redis = redis_client || Redis.new
    @logger = Logger.new(STDOUT)
  end
  
  def create_user(user_params)
    ActiveRecord::Base.transaction do
      user = User.new(user_params)
      
      if user.save
        send_welcome_email(user)
        clear_user_cache
        log_user_creation(user)
        user
      else
        raise ValidationError, user.errors.full_messages.join(', ')
      end
    end
  rescue StandardError => e
    @logger.error "用户创建失败: #{e.message}"
    raise e
  end
  
  def get_users(page: 1, per_page: 10)
    cache_key = "users:page:#{page}:per_page:#{per_page}"
    
    cached_result = @redis.get(cache_key)
    return JSON.parse(cached_result, symbolize_names: true) if cached_result
    
    users = User.active
                .order(created_at: :desc)
                .limit(per_page)
                .offset((page - 1) * per_page)
    
    result = {
      users: users.map(&method(:serialize_user)),
      pagination: {
        current_page: page,
        per_page: per_page,
        total_count: User.active.count
      }
    }
    
    @redis.setex(cache_key, 300, result.to_json)
    result
  end
  
  def find_user(user_id)
    cache_key = "user:#{user_id}"
    
    cached_user = @redis.get(cache_key)
    return JSON.parse(cached_user, symbolize_names: true) if cached_user
    
    user = User.find(user_id)
    raise UserNotFoundError, "用户ID #{user_id} 不存在" unless user&.active?
    
    serialized_user = serialize_user(user)
    @redis.setex(cache_key, 600, serialized_user.to_json)
    serialized_user
  end
  
  def update_user(user_id, update_params)
    user = User.find(user_id)
    raise UserNotFoundError, "用户ID #{user_id} 不存在" unless user
    
    ActiveRecord::Base.transaction do
      user.update!(update_params.merge(updated_at: Time.current))
      clear_user_cache(user_id)
      serialize_user(user)
    end
  rescue ActiveRecord::RecordInvalid => e
    raise ValidationError, e.record.errors.full_messages.join(', ')
  end
  
  def delete_user(user_id)
    user = User.find(user_id)
    raise UserNotFoundError, "用户ID #{user_id} 不存在" unless user
    
    user.soft_delete!
    clear_user_cache(user_id)
    @logger.info "用户已删除: #{user_id}"
    true
  end
  
  def get_user_stats
    cache_key = 'user_stats'
    
    cached_stats = @redis.get(cache_key)
    return JSON.parse(cached_stats, symbolize_names: true) if cached_stats
    
    stats = {
      total_users: User.count,
      active_users: User.active.count,
      new_users_today: User.created_today.count,
      new_users_this_month: User.created_this_month.count
    }
    
    @redis.setex(cache_key, 3600, stats.to_json)
    stats
  end
  
  private
  
  def serialize_user(user)
    {
      id: user.id,
      username: user.username,
      email: user.email,
      is_active: user.is_active,
      created_at: user.created_at.iso8601,
      updated_at: user.updated_at&.iso8601
    }
  end
  
  def send_welcome_email(user)
    WelcomeEmailJob.perform_async(user.id)
  rescue StandardError => e
    @logger.warn "欢迎邮件发送失败: #{e.message}"
  end
  
  def clear_user_cache(user_id = nil)
    if user_id
      @redis.del("user:#{user_id}")
    end
    
    # 清除分页缓存
    keys = @redis.keys('users:page:*')
    @redis.del(*keys) if keys.any?
    
    @redis.del('user_stats')
  end
  
  def log_user_creation(user)
    @logger.info "用户创建成功: ID=#{user.id}, Username=#{user.username}"
  end
end

# 自定义异常
class UserServiceError < StandardError; end
class UserNotFoundError < UserServiceError; end
class ValidationError < UserServiceError; end

# 后台任务
class WelcomeEmailJob
  include Sidekiq::Worker
  
  def perform(user_id)
    user = User.find(user_id)
    return unless user
    
    mail = Mail.new do
      from     'noreply@example.com'
      to       user.email
      subject  '欢迎加入我们！'
      body     "亲爱的 #{user.username}，欢迎加入我们的平台！"
    end
    
    mail.deliver!
  rescue StandardError => e
    logger.error "发送欢迎邮件失败: #{e.message}"
  end
end

# 使用示例
if __FILE__ == $0
  # 数据库连接配置
  ActiveRecord::Base.establish_connection(
    adapter: 'postgresql',
    host: 'localhost',
    database: 'user_management',
    username: 'postgres',
    password: 'password'
  )
  
  # 创建用户服务实例
  user_service = UserService.new
  
  begin
    # 创建用户
    user = user_service.create_user(
      username: 'testuser',
      email: 'test@example.com',
      password: 'SecurePassword123'
    )
    
    puts "用户创建成功: #{user[:username]}"
    
    # 获取用户列表
    users = user_service.get_users(page: 1, per_page: 10)
    puts "找到 #{users[:users].length} 个用户"
    
    # 获取统计信息
    stats = user_service.get_user_stats
    puts "用户统计: #{stats}"
    
  rescue UserServiceError => e
    puts "错误: #{e.message}"
  end
end
```

---

这个 Markdown 文档包含了多种编程语言的代码示例，涵盖了：

- **前端语言**: HTML, CSS, JavaScript, TypeScript
- **后端语言**: Python, Java, C#, Go, Rust
- **数据库**: SQL
- **配置文件**: YAML, JSON, XML
- **脚本语言**: Bash, PHP, Ruby

每个代码块都使用了相应的语言标识符，应该能够正确触发语法高亮。代码示例都是实际可用的，展示了各种语言的常见模式和最佳实践。
